/*
 * HmSplitTextFileByRegex v1.0.1.0
 *
 * Copyright (c) 2024 Akitsugu Komiyama
 * under the MIT License
 */



hidemaruversion "9.25.99";

setcompatiblemode 0x00020000; // ユーザーが利用する普段の検索条件を保存しておき、このマクロ終了後に元へと戻す。

jsmode "WebView2";
execjs currentmacrodirectory + @"\HmSplitTextFileByRegex.help.js";


jsmode "WebView2";
js {

try {
    /*
    function outputAlert(err) {
        let dll = loaddll("HmOutputPane.dll");
        dll.dllFunc.Output(hidemaru.getCurrentWindowHandle(), err + "\r\n");
    }

    function throwIfNotFileName() {
        // ファイル名無しは対象にしない
        if (!hidemaru.getFileFullPath()) {
            outputAlert("ファイル名が付いているファイルのみ対象とします。");
            throwCancelException();
        }
    }
    */

    function throwInvalidDivideType() {
        throw "指定の分割方法は適切な数値ではありません。"
    }

    function throwCancelException() {
        throw "実行をキャンセルしました。";
    }

    // 1 :「そのワードでSplit」するタイプ、
    // 2 :「ワードが登場すると、ワードを含めて次のファイル」にするタイプ、
    // 3 :「ワードが登場すると、そのワードまでをファイルとし、次の文字から次のファイルとする」タイプ
    function getDivideType() {

        // ２番目の引数として分割タイプが外部から指定されているなら、数値に直して
        let answer = getarg(1);

        // 何も指定がないなら、ここで簡易インターフェイスで入力
        if (answer == "") {
            let strQuestion =
            `
            分割タイプはどれにしますか？ 1-3で入力してください。

            　1:【ファイル1】 検索ワード 【ファイル2】...
            　2:【ファイル1】 【検索ワード ファイル2】...
            　3:【ファイル1 検索ワード】 【ファイル2】...
            `.replace(/^ +/mg, "");
            answer = input(strQuestion);
        }

        if (answer=="") { throwCancelException(); }

        let nDivideType = Number(answer);
        if (Number.isNaN(nDivideType)) {
            throwInvalidDivideType();
        }
        if (1 <= nDivideType && nDivideType <= 3) {
            ; // 問題なし
        } else {
            throwInvalidDivideType();
        }

        return nDivideType;
    }

    function splitText(items, nDivideType) {
        let chunks = [];

        let bottom_len = linelen_wcs(linecount2() - 1);
        let prevCol = 0;
        let prevLine = 1;

        // タイプ①＝splitタイプであれば、間の文字列部分は採用しないのだから、(col1,line1)までを採用し、次は(col2, line2)となる。
        if (nDivideType == 1) {

            for (let item of items) {
                console.log(JSON.stringify(item) + "\r\n");

                let text = gettext_wcs(prevCol, prevLine, item.col1, item.line1, 1);

                chunks.push(text);

                prevCol = item.col2;
                prevLine = item.line2;
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }

        // ワード登場が新たなファイルとなるタイプ②なのであれば、(col1,line1)までを採用し、次は(col1, line1)からとなる。
        else if (nDivideType == 2) {

            for (let item of items) {
                console.log(JSON.stringify(item) + "\r\n");

                let text = gettext_wcs(prevCol, prevLine, item.col1, item.line1, 1);

                chunks.push(text);

                prevCol = item.col1;
                prevLine = item.line1;
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }

        // ワード登場するまでが前のファイルとなるタイプ③なのであれば、(col2,line2)までを採用し、次は(col2, line2)からとなる。
        else if (nDivideType == 3) {

            for (let item of items) {
                console.log(JSON.stringify(item) + "\r\n");

                let text = gettext_wcs(prevCol, prevLine, item.col2, item.line2, 1);

                chunks.push(text);

                prevCol = item.col12
                prevLine = item.line12
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }


        // chunksの最後の要素が""になってしまっていたら、それは連番ファイルとして保存しても無意味なので、カット
        if (chunks[chunks.length - 1] === "") {
            chunks.pop();
        }

        return chunks;
    }

    function getPerChunk() {

        // このマクロの引数として行数が指定されている。
        let answer = getarg(0);
        let needConfirm = true;
        if (answer != "") {
            needConfirm = false;
        }

        deletecolormarkerall(findmarker());
        gofiletop();
        const op_casesense = 0x00000002; // 秀丸のsearchdown関数のcasesenseと同じ意味
        const op_regular = 0x00000010; // 秀丸のsearchdown関数のregularと同じ意味
        const op_hilight = 0x00003800; // 秀丸のsearchdown関数のhilightと同じ意味
        const op_loop = 0x01000000; // 秀丸のsearchdown関数のloopと同じ意味

        // 指定がないなら視覚的にもダイアログを出す
        if (answer == "") {
            searchdialog("分離したい箇所のパターンの正規表現の入力", op_regular | op_hilight | op_casesense | op_loop);

        // 指定があるなら視覚的には出さない
        } else {
            searchdown("分離したい箇所のパターンの正規表現の入力", op_regular | op_hilight | op_casesense | op_loop);
        }
        colormarkerallfound();

        let getcolormarker_arg_request_json = {
            unit: "wcs",
            layer: findmarker(),
            items: [
                { line1: "*", col1: "*", line2: "*", col2: "*", },
            ]
        };

        let info = getcolormarker(getcolormarker_arg_request_json);
        if (info.items) {
            let items = info.items;
            return [items, needConfirm];
        } else {
            throw "分離情報取得でエラーが発生しました。";
        }
    }

    function confirmExecution(text) {
        let buttonOkCancel = 0x0001;
        let dialogResult = message(text, "実行確認", buttonOkCancel);

        // キャンセル・中止・いいえ などなら false
        // (少々 messageダイアログのボタンタイプを変更してもいいようにここで柔らかく対応しておく)
        if (dialogResult == 2 || dialogResult == 3 || dialogResult == 7) {
            return false;
        }
        return true;
    }

    function getFilePathInfo(filePath) {

        // '.' でファイル名を拡張子とそれ以外に分割して配列に格納
        let parts = filePath.split('.');

        // 拡張子とそれ以外を別々の変数に格納
        let ext = parts.pop(); // 拡張子
        let name = parts.join('.'); // 拡張子以外の部分

        return {
            name: name,
            ext: ext
        };
    }

    function saveChunksToFiles(chunks) {

        let cp = codepage();
        let hasbom = bom();

        function getTargetEncode() {
            switch (cp) {
                case 932: return "sjis";
                case 1200: return "utf16";
                case 65001: return hasbom ? "utf8bom" : "utf8";
            }

            return "utf8";
        }

        let fname = hidemaru.getFileFullPath();
        let enc = getTargetEncode();

        let maxFormatLength = chunks.length.toString().length;

        for (let i = 0; i < chunks.length; i++) {
            let pathAttr = getFilePathInfo(fname);
            // 配列の個数を文字列化したその文字列の長さに足りない部分を0埋めすればよい。
            // 配列の個数が30個なら、"30"という文字列の長さ、すなわち2文字。
            // 現在の数値が3なら3を文字列化して足りない文字数すなわち1つが0で埋まる
            const zeroFormatNumber = (i + 1).toString().padStart(maxFormatLength, '0');

            // ファイル名を新たに分割したファイル名に
            let newFileName = `${pathAttr.name}_${zeroFormatNumber}.${pathAttr.ext}`;
            hidemaru.saveTextFile(newFileName, chunks[i], enc);
        }
    }

    var nDivideType_HmSplitTextFileByRegex = -1; // 広範に非同期でも参照されるため、varにして重ならない変数名で
    function main() {

        throwIfNotFileName();

        showHelp();

        // 何行に分割するかを得る
        let [colorMarkerItems, needConfirm] = getPerChunk();

        let nDivideType = getDivideType();

        // テキストを分割して配列に格納
        const chunks = splitText(colorMarkerItems, nDivideType);

        if (needConfirm) {
            // 最後の実行確認
            if (confirmExecution(chunks.length + "個のファイルに分割しますか？") == false) {
                throwCancelException();
            }
        }

        // 分割したテキストを分割してファイルに保存
        saveChunksToFiles(chunks);

        outputAlert(chunks.length + "個のファイルに分割しました。");
    }


    main()

} catch (err) {
    outputAlert(err);
}

}