/*
 * HmSplitTextFileByRegex v1.0.1.0
 *
 * Copyright (c) 2024 Akitsugu Komiyama
 * under the MIT License
 */



hidemaruversion "9.25.99";

setcompatiblemode 0x00020000; // ユーザーが利用する普段の検索条件を保存しておき、このマクロ終了後に元へと戻す。

// これを「秀丸マクロの層」で入れて表示だけでもしておかないと、JSからキックしたら１秒ほど遅くなってしまう。
if (filename2 != "") {
	renderpanecommand
	""""""""""""""""""""""""""""""""""""""""
	{
	    "target": "HmSplitTextFileByRegex",
	    "show": 1,
	}
	"""""""""""""""""""""""""""""""""""""""";
}

jsmode "WebView2";
js {

// 最初のレンダリングペインCompleteチェック用のものは、比較的細やかにチェックする。
// これは表示しをえたら直ぐにIntervalが止まるのでIntervalが小さくでも大丈夫
var idIntervalInitialize_HmSplitTextFileByRegex;

// ラベルはこのマクロ独自にしておく
let strTargetLabel_HmSplitTextFileByRegex = "HmSplitTextFileByRegex";

function showHelp_HmSplitTextFileByRegex() {

    const currentmacrodir_HmSplitTextFileByRegex = currentmacrodirectory();

	try {

	    // レンダリングペインを開く
	    function openRenderPane() {
	        // カレントマクロフォルダのhtmlファイルを使う
	        const absoluteUrl = new URL(currentmacrodir_HmSplitTextFileByRegex + "\\" + "HmSplitTextFileByRegex.help.html").href;


	        const json_arg = {
	            target: strTargetLabel_HmSplitTextFileByRegex,
	            uri: absoluteUrl,
	            show: 1,
	            place: "leftside",
	        };

	        renderpanecommand(json_arg);
	    }

	    // 本当にレンダリングペインが開いて準備がととのったのかのチェック
	    let checkCount_HmSplitTextFileByRegex = 0;
	    function checkComplete_HmSplitTextFileByRegex() {
	        let readyState = renderpanecommand({ target: strTargetLabel_HmSplitTextFileByRegex, get: "readyState" });
	        if (readyState == "complete") {
	            hidemaru.clearInterval(idIntervalInitialize_HmSplitTextFileByRegex);
	        }
	    }

	    openRenderPane();

	    // 次のマクロ実行の際に見るのでletではなくvarにして、ライフサイクルを js { } 外に伸ばす必要がある。
	    // 他のjsを使った秀丸マクロと決して被らない「マクロ空間」にしておく必要がある。(よってtickcount空間という被らない空間に配置している)
	    if (typeof (idIntervalInitialize_HmSplitTextFileByRegex) != "undefined") {
	        hidemaru.clearInterval(idIntervalInitialize_HmSplitTextFileByRegex);
	    }
	    idIntervalInitialize_HmSplitTextFileByRegex = hidemaru.setInterval(checkComplete_HmSplitTextFileByRegex, 300);
	} catch(err) {
	    outputAlert(err);
	}
}


} // js

jsmode "WebView2";
js {

// 最初のレンダリングペインCompleteチェック用のものは、比較的細やかにチェックする。
// これは表示しをえたら直ぐにIntervalが止まるのでIntervalが小さくでも大丈夫
var idIntervalDivideInit_HmSplitTextFileByRegex;

let nDivideType_HmSplitTextFileByRegex = 0;

// ラベルはこのマクロ独自にしておく
let strTargetLabel_HmSplitTextFileByRegex = "HmSplitTextFileByRegex";
function showDivide_HmSplitTextFileByRegex(nDivFileCount) {
    const currentmacrodir_HmSplitTextFileByRegex = currentmacrodirectory();

    nDivideType_HmSplitTextFileByRegex = 0;
	try {

	    // レンダリングペインを開く
	    function openRenderPane() {
	        // カレントマクロフォルダのhtmlファイルを使う
	        const absoluteUrl = new URL(currentmacrodir_HmSplitTextFileByRegex + "\\" + "HmSplitTextFileByRegex.divide.html").href;

            console.log(absoluteUrl);
	        const json_arg = {
	            target: strTargetLabel_HmSplitTextFileByRegex,
	            uri: absoluteUrl,
	            show: 1,
	            place: "leftside",
	        };

	        renderpanecommand(json_arg);
	    }

	    // 本当にレンダリングペインが開いて準備がととのったのかのチェック
	    let checkCount_HmSplitTextFileByRegex = 0;
	    function checkComplete_HmSplitTextFileByRegex() {
	        let readyState = renderpanecommand({ target: strTargetLabel_HmSplitTextFileByRegex, get: "readyState" });
	        if (readyState == "complete") {
	            hidemaru.clearInterval(idIntervalDivideInit_HmSplitTextFileByRegex);
                onRenderPaneShown_HmSplitTextFileByRegex();
	        }
	    }


        // レンダリングペインが完全に表示されたら、
        // このJS内にある「onInputHtmlButtonClick_HmSplitTextFileByRegex」関数をレンダリングペインから呼び出せるように関数のIDを渡す。
        // また、「レンダリングペインを操作するのよ～」ということがわかりやすいように、レンダリングペイン側にフォーカスを移す
        function onRenderPaneShown_HmSplitTextFileByRegex() {
            let idCallback = hidemaru.getFunctionId(onInputHtmlButtonClick_HmSplitTextFileByRegex);
            renderpanecommand({
                target: strTargetLabel_HmSplitTextFileByRegex,
                uri: 'javascript:nDivFileCount=' + nDivFileCount + ';',
            });
            renderpanecommand({
                target: strTargetLabel_HmSplitTextFileByRegex,
                uri: 'javascript:idCallback=' + idCallback + ';',
            });
            renderpanecommand({
                target: strTargetLabel_HmSplitTextFileByRegex,
                focus: 1,
            });


        }

        // HTML側で「ボタン」を押すと、これが呼ばれる
        function onInputHtmlButtonClick_HmSplitTextFileByRegex(json_text) {
            hidemaru.clearInterval(idIntervalDivideInit_HmSplitTextFileByRegex);
            renderpanecommand({
                target: strTargetLabel_HmSplitTextFileByRegex,
                show: 0,
            });

            // json_textの状態で、inputフィールドに入っているテキストが渡ってくるので、その数値を渡す
            let json_obj = JSON.parse(json_text);
            let divtype = json_obj.divtype;
            hidemaru.postExecMacroMemory( "js { postProcedure_HmSplitTextFileByRegex(" + divtype + ") }" );
        }

	    openRenderPane();

	    // 次のマクロ実行の際に見るのでletではなくvarにして、ライフサイクルを js { } 外に伸ばす必要がある。
	    // 他のjsを使った秀丸マクロと決して被らない「マクロ空間」にしておく必要がある。(よってtickcount空間という被らない空間に配置している)
	    if (typeof (idIntervalDivideInit_HmSplitTextFileByRegex) != "undefined") {
	        hidemaru.clearInterval(idIntervalDivideInit_HmSplitTextFileByRegex);
	    }
	    idIntervalDivideInit_HmSplitTextFileByRegex = hidemaru.setInterval(checkComplete_HmSplitTextFileByRegex, 300);
	} catch(err) {
	    outputAlert(err);
	}
}

} // js

jsmode "WebView2";
js {

try {
    function outputAlert(err) {
        let dll = loaddll("HmOutputPane.dll");
        dll.dllFunc.Output(hidemaru.getCurrentWindowHandle(), err + "\r\n");
    }

    function throwIfNotFileName() {
        // ファイル名無しは対象にしない
        if (!hidemaru.getFileFullPath()) {
            outputAlert("ファイル名が付いているファイルのみ対象とします。");
            throwCancelException();
        }
    }

    function throwInvalidDivideType() {
        throw "指定の分割方法は適切な数値ではありません。"
    }

    function throwCancelException() {
        throw "実行をキャンセルしました。";
    }

    // 1 :「そのワードでSplit」するタイプ、
    // 2 :「ワードが登場すると、ワードを含めて次のファイル」にするタイプ、
    // 3 :「ワードが登場すると、そのワードまでをファイルとし、次の文字から次のファイルとする」タイプ
    function getDivideType() {
        // ２番目の引数として分割タイプが外部から指定されているなら、数値に直して
        let answer = getarg(1);
        if (answer != "") {
	        let nDivideType = Number(answer);
	        if (Number.isNaN(nDivideType)) {
	            throwInvalidDivideType();
	        }
	        if (1 <= nDivideType && nDivideType <= 3) {
	            ; // 問題なし
	        } else {
	            throwInvalidDivideType();
	        }
        }

        answer = "1";
        if (answer=="") { throwCancelException(); }

        let nDivideType = Number(answer);
        if (Number.isNaN(nDivideType)) {
            throwInvalidDivideType();
        }
        if (1 <= nDivideType && nDivideType <= 3) {
            ; // 問題なし
        } else {
            throwInvalidDivideType();
        }

        return nDivideType;
    }

    function splitText(items, nDivideType) {
        let chunks = [];

        let bottom_len = linelen_wcs(linecount2() - 1);
        let prevCol = 0;
        let prevLine = 1;

        // タイプ①＝splitタイプであれば、間の文字列部分は採用しないのだから、(col1,line1)までを採用し、次は(col2, line2)となる。
        if (nDivideType == 1) {

            for (let item of items) {
                let text = gettext_wcs(prevCol, prevLine, item.col1, item.line1, 1);

                chunks.push(text);

                prevCol = item.col2;
                prevLine = item.line2;
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }

        // ワード登場が新たなファイルとなるタイプ②なのであれば、(col1,line1)までを採用し、次は(col1, line1)からとなる。
        else if (nDivideType == 2) {

            for (let item of items) {
                let text = gettext_wcs(prevCol, prevLine, item.col1, item.line1, 1);

                chunks.push(text);

                prevCol = item.col1;
                prevLine = item.line1;
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }

        // ワード登場するまでが前のファイルとなるタイプ③なのであれば、(col2,line2)までを採用し、次は(col2, line2)からとなる。
        else if (nDivideType == 3) {

            for (let item of items) {

                let text = gettext_wcs(prevCol, prevLine, item.col2, item.line2, 1);

                chunks.push(text);

                prevCol = item.col12
                prevLine = item.line12
            }
            let text = gettext_wcs(prevCol, prevLine, bottom_len + 1, linecount2() + 1, 1);
            chunks.push(text);
        }


        // chunksの最後の要素が""になってしまっていたら、それは連番ファイルとして保存しても無意味なので、カット
        if (chunks[chunks.length - 1] === "") {
            chunks.pop();
        }

        return chunks;
    }

    function isNeedConfirm() {
        // このマクロの引数として行数が指定されている。
        let answer = getarg(0);
        let needConfirm = true;
        if (answer != "") {
            needConfirm = false;
        }
        return needConfirm
    }

    function getPerChunk() {

        // このマクロの引数として行数が指定されている。
        let answer = getarg(0);

        deletecolormarkerall(findmarker());
        gofiletop();
        const op_casesense = 0x00000002; // 秀丸のsearchdown関数のcasesenseと同じ意味
        const op_regular = 0x00000010; // 秀丸のsearchdown関数のregularと同じ意味
        const op_hilight = 0x00003800; // 秀丸のsearchdown関数のhilightと同じ意味
        const op_loop = 0x01000000; // 秀丸のsearchdown関数のloopと同じ意味

        // 指定がないなら視覚的にもダイアログを出す
        if (answer == "") {
            let success = searchdialog("分離したい箇所のパターンの正規表現の入力", op_regular | op_hilight | op_casesense | op_loop);
            if (!success) { throw "検索に失敗しました"; }
            if (success==-2) { throwCancelException(); }

        // 指定があるなら視覚的には出さない
        } else {
            let success = searchdown(answer, op_regular | op_hilight | op_casesense | op_loop);
            if (!success) { throw "検索に失敗しました"; }
        }
        colormarkerallfound();

        let getcolormarker_arg_request_json = {
            unit: "wcs",
            layer: findmarker(),
            items: [
                { line1: "*", col1: "*", line2: "*", col2: "*", },
            ]
        };

        let info = getcolormarker(getcolormarker_arg_request_json);
        if (info.items) {
            let items = info.items;
            return items;
        } else {
            throw "分離情報取得でエラーが発生しました。";
        }
    }

    function confirmExecution(text) {
        let buttonOkCancel = 0x0001;
        let dialogResult = message(text, "実行確認", buttonOkCancel);

        // キャンセル・中止・いいえ などなら false
        // (少々 messageダイアログのボタンタイプを変更してもいいようにここで柔らかく対応しておく)
        if (dialogResult == 2 || dialogResult == 3 || dialogResult == 7) {
            return false;
        }
        return true;
    }

    function getFilePathInfo(filePath) {

        // '.' でファイル名を拡張子とそれ以外に分割して配列に格納
        let parts = filePath.split('.');

        // 拡張子とそれ以外を別々の変数に格納
        let ext = parts.pop(); // 拡張子
        let name = parts.join('.'); // 拡張子以外の部分

        return {
            name: name,
            ext: ext
        };
    }

    function saveChunksToFiles(chunks) {

        let cp = codepage();
        let hasbom = bom();

        function getTargetEncode() {
            switch (cp) {
                case 932: return "sjis";
                case 1200: return "utf16";
                case 65001: return hasbom ? "utf8bom" : "utf8";
            }

            return "utf8";
        }

        let fname = hidemaru.getFileFullPath();
        let enc = getTargetEncode();

        let maxFormatLength = chunks.length.toString().length;

        for (let i = 0; i < chunks.length; i++) {
            let pathAttr = getFilePathInfo(fname);
            // 配列の個数を文字列化したその文字列の長さに足りない部分を0埋めすればよい。
            // 配列の個数が30個なら、"30"という文字列の長さ、すなわち2文字。
            // 現在の数値が3なら3を文字列化して足りない文字数すなわち1つが0で埋まる
            const zeroFormatNumber = (i + 1).toString().padStart(maxFormatLength, '0');

            // ファイル名を新たに分割したファイル名に
            let newFileName = `${pathAttr.name}_${zeroFormatNumber}.${pathAttr.ext}`;
            hidemaru.saveTextFile(newFileName, chunks[i], enc);
        }
    }

    let gColorMarkerItems = null;

	function prevProcedure_HmSplitTextFileByRegex() {

        // 検索に入れてねというヘルプ
        showHelp_HmSplitTextFileByRegex();

        // 何行に分割するかを得る
        gColorMarkerItems = getPerChunk();


       debuginfo(2);
        console.log(gColorMarkerItems.length);
        // どの分割タイプかという決定
        showDivide_HmSplitTextFileByRegex(gColorMarkerItems.length);
    }

    function postProcedure_HmSplitTextFileByRegex(nDivideType) {

        // テキストを分割して配列に格納
        const chunks = splitText(gColorMarkerItems, nDivideType);

        // 最後の実行確認
        if (confirmExecution(chunks.length + "個のファイルに分割しますか？") == false) {
            throwCancelException();
        }

        // 分割したテキストを分割してファイルに保存
        saveChunksToFiles(chunks);
        // console.log(chunks.join("\r\n---------\r\n"));

        outputAlert(chunks.length + "個のファイルに分割しました。");

    }

    function main() {

        throwIfNotFileName();

        let needConfirm = isNeedConfirm();

        if (needConfirm) {
            prevProcedure_HmSplitTextFileByRegex();

		} else {

	        // 何行に分割するかを得る
	        let colorMarkerItems = getPerChunk();

	        let nDivideType = getDivideType();
 	        const chunks = splitText(colorMarkerItems, nDivideType);

	        // 分割したテキストを分割してファイルに保存
	        saveChunksToFiles(chunks);
	        // console.log(chunks.join("\r\n---------\r\n"));

	        outputAlert(chunks.length + "個のファイルに分割しました。");
       }

    }


    main()

} catch (err) {
    outputAlert(err);
}

}