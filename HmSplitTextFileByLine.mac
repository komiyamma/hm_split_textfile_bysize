/*
 * HmSplitTextFileByLine v1.0.3.0
 *
 * Copyright (c) 2024 Akitsugu Komiyama
 * under the MIT License
 */

hidemaruversion "9.25.99";

jsmode "WebView2";
js {

try {
    // ファイル名無しは対象にしない
    if (!hidemaru.getFileFullPath()) {
        throw "ファイル名が付いているファイルのみ対象とします。";
    }

    function outputAlert(err) {
        let dll = loaddll("HmOutputPane.dll");
        dll.dllFunc.Output(hidemaru.getCurrentWindowHandle(), err + "\r\n");
    }

    function throwCancelException() {
        throw "実行をキャンセルしました。";
    }

    function getPerChunk() {
        let answer = input("何行で分けますか?");
        if (answer=="") { throwCancelException(); }

        try {
            let linesPerChunk = 5000;
            linesPerChunk = Number(answer);
            if (Number.isNaN(linesPerChunk)) {
                throwCancelException();
            }
            return linesPerChunk;
        } catch (err) {
            throwCancelException();
        }
    }

    // 対象のテキストを該当の行数で割って配列にして返す
    function splitText(text, linesPerChunk) {
        const chunks = [];
        const textArray = text.split('\n');

        for (let i = 0; i < textArray.length; i += linesPerChunk) {
            chunks.push(textArray.slice(i, i + linesPerChunk).join('\n'));
        }

        // chunksの最後の要素が""になってしまっていたら、それは連番ファイルとして保存しても無意味なので、カット
        if (chunks[chunks.length-1] === "") {
            chunks.pop();
        }

        return chunks;
    }

    function getFilePathInfo(filePath) {

        // '.' でファイル名を拡張子とそれ以外に分割して配列に格納
        let parts = filePath.split('.');

        // 拡張子とそれ以外を別々の変数に格納
        let ext = parts.pop(); // 拡張子
        let name = parts.join('.'); // 拡張子以外の部分

        return {
            name: name,
            ext: ext
        };
    }

    function saveChunksToFiles(chunks) {

        let cp = codepage();
        let hasbom = bom();

        function getTargetEncode() {
            switch (cp) {
                case 932: return "sjis";
                case 1200: return "utf16";
                case 65001: return hasbom ? "utf8bom" : "utf8";
            }

            return "utf8";
        }

        let fname = hidemaru.getFileFullPath();
        let enc = getTargetEncode();

        let maxFormatLength = chunks.length.toString().length;

        for (let i = 0; i < chunks.length; i++) {
            let pathAttr = getFilePathInfo(fname);
            // 配列の個数を文字列化したその文字列の長さに足りない部分を0埋めすればよい。
            // 配列の個数が30個なら、"30"という文字列の長さ、すなわち2文字。
            // 現在の数値が3なら3を文字列化して足りない文字数すなわち1つが0で埋まる
            const zeroFormatNumber = (i + 1).toString().padStart(maxFormatLength, '0');

            // ファイル名を新たに分割したファイル名に
            let newFileName = `${pathAttr.name}_${zeroFormatNumber}.${pathAttr.ext}`;
            hidemaru.saveTextFile(newFileName, chunks[i], enc);
        }
    }


    function confirmExecution(text) {
        let buttonOkCancel = 0x0001;
        let dialogResult = message(text, "実行確認", buttonOkCancel);

        // キャンセル・中止・いいえ などなら false
        // (少々 messageダイアログのボタンタイプを変更してもいいようにここで柔らかく対応しておく)
        if (dialogResult == 2 || dialogResult == 3 || dialogResult == 7) {
            return false;
        }
        return true;
    }

    function main() {
        // 何行に分割するかを得る
        let linesPerChunk = getPerChunk();
        // 現在のテキストを取得
        const text = hidemaru.getTotalText();
        // テキストを分割して配列に格納
        const chunks = splitText(text, linesPerChunk);

        // 最後の実行確認
        if (confirmExecution(chunks.length + "個のファイルに分割しますか？") == false) {
            throwCancelException();
        }

        // 分割したテキストを分割してファイルに保存
        saveChunksToFiles(chunks);

        outputAlert(chunks.length + "個のファイルに分割しました。");
    }

    main();

} catch (err) {
    outputAlert(err);
}


} // js